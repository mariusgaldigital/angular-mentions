{"version":3,"sources":["ng://angular-mentions/lib/mention-utils.ts","ng://angular-mentions/lib/caret-coords.ts","ng://angular-mentions/lib/mention-list.component.ts","ng://angular-mentions/lib/mention.directive.ts","ng://angular-mentions/lib/mention.module.ts"],"names":["getValue","el","isInputOrTextAreaElement","value","textContent","insertValue","start","end","text","iframe","noRecursion","isTextElement","nodeName","val","setValue","substring","length","setCaretPosition","selObj","getWindowSelection","rangeCount","position","getRangeAt","startOffset","anchorNode","pos","selectionStart","focus","setSelectionRange","range","getDocument","createRange","setStart","collapse","sel","removeAllRanges","addRange","getCaretPosition","slice","selRange","preCaretRange","cloneRange","selectNodeContents","setEnd","endContainer","endOffset","toString","contentWindow","document","getSelection","window","getContentEditableCaretCoords","ctx","markerId","Date","getTime","Math","random","substr","doc","prevRange","markerEl","createElement","id","appendChild","createTextNode","insertNode","coordinates","left","top","offsetHeight","localToRelativeCoordinates","element","obj","parent","offsetLeft","clientLeft","offsetTop","clientTop","body","scrollTop","scrollLeft","parentNode","removeChild","properties","isBrowser","isFirefox","MentionListComponent","prototype","ngOnInit","this","itemTemplate","defaultItemTemplate","nativeParentElement","coords","getCaretCoordinates","options","Error","debug","querySelector","div","style","computed","getComputedStyle","currentStyle","isInput","whiteSpace","wordWrap","visibility","forEach","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","scrollHeight","overflowY","overflow","replace","span","backgroundColor","offset","getBlockCursorDimensions","context","offsetParent","documentElement","pageXOffset","pageYOffset","caretRelativeToView","parentRelativeToContainer","getBoundingClientRect","positionElement","Object","defineProperty","items","activeIndex","activateNextItem","listEl","list","nativeElement","activeEl","getElementsByClassName","item","nextLiEl","nextLiRect","bottom","clientHeight","max","min","activatePreviousItem","prevLiEl","reset","checkBounds","dropUp","bounds","width","innerWidth","className","parentStyles","parseFloat","fontSize","Component","args","selector","template","ElementRef","Input","Output","ViewChild","labelKey","itemClick","EventEmitter","hidden","styleOff","MentionDirective","mentionItems","ngOnChanges","changes","updateConfig","_this","config","mentionConfig","triggerChars","addConfig","mentions","defaults","assign","DEFAULT_CONFIG","map","label","object","filter","e","disableSort","sort","a","b","localeCompare","triggerChar","activeConfig","updateSearchList","setIframe","stopEvent","event","wasClick","preventDefault","stopPropagation","stopImmediatePropagation","blurHandler","stopSearch","inputHandler","_element","lastKeyCode","data","keyCode","charCodeAt","keyDownHandler","inputEvent","keyPressHandler","isComposing","charPressed","extractCharPressed","startPos","startNode","searching","searchString","showSearchList","searchList","metaKey","altKey","ctrlKey","allowSpace","mentionSelect","activeItem","evt","createEvent","initEvent","dispatchEvent","mention","searchTerm","emit","matches","objects","disableSearch","searchStringLowerCase_1","toLowerCase","startsWith","maxItems","componentFactory","_componentResolver","resolveComponentFactory","componentRef","_viewContainerRef","createComponent","instance","mentionListTemplate","subscribe","fakeKeydown","disableStyle","setTimeout","key","charCode","which","shiftKey","String","fromCharCode","Directive","host","(keydown)","(keypress)","(blur)","autocomplete","ComponentFactoryResolver","ViewContainerRef","MentionModule","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"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","sourcesContent":["// DOM element manipulation functions...\n//\n\nfunction setValue(el: HTMLInputElement, value: any) {\n  //console.log(\"setValue\", el.nodeName, \"[\"+value+\"]\");\n  if (isInputOrTextAreaElement(el)) {\n    el.value = value;\n  }\n  else {\n    el.textContent = value;\n  }\n}\n\nexport function getValue(el: HTMLInputElement) {\n  return isInputOrTextAreaElement(el) ? el.value : el.textContent;\n}\n\nexport function insertValue(\n  el: HTMLInputElement,\n  start: number,\n  end: number,\n  text: string,\n  iframe: HTMLIFrameElement,\n  noRecursion: boolean = false\n) {\n  //console.log(\"insertValue\", el.nodeName, start, end, \"[\"+text+\"]\", el);\n  if (isTextElement(el)) {\n    let val = getValue(el);\n    setValue(el, val.substring(0, start) + text + val.substring(end, val.length));\n    setCaretPosition(el, start + text.length, iframe);\n  }\n  else if (!noRecursion) {\n    let selObj: Selection = getWindowSelection(iframe);\n    if (selObj && selObj.rangeCount > 0) {\n      var selRange = selObj.getRangeAt(0);\n      var position = selRange.startOffset;\n      var anchorNode = selObj.anchorNode;\n      // if (text.endsWith(' ')) {\n      //   text = text.substring(0, text.length-1) + '\\xA0';\n      // }\n      insertValue(<HTMLInputElement>anchorNode, position - (end - start), position, text, iframe, true);\n    }\n  }\n}\n\nexport function isInputOrTextAreaElement(el: HTMLElement): boolean {\n  return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA');\n};\n\nexport function isTextElement(el: HTMLElement): boolean {\n  return el != null && (el.nodeName == 'INPUT' || el.nodeName == 'TEXTAREA' || el.nodeName == '#text');\n};\n\nexport function setCaretPosition(el: HTMLInputElement, pos: number, iframe: HTMLIFrameElement = null) {\n  //console.log(\"setCaretPosition\", pos, el, iframe==null);\n  if (isInputOrTextAreaElement(el) && el.selectionStart) {\n    el.focus();\n    el.setSelectionRange(pos, pos);\n  }\n  else {\n    let range = getDocument(iframe).createRange();\n    range.setStart(el, pos);\n    range.collapse(true);\n    let sel = getWindowSelection(iframe);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}\n\nexport function getCaretPosition(el: HTMLInputElement, iframe: HTMLIFrameElement = null) {\n  //console.log(\"getCaretPosition\", el);\n  if (isInputOrTextAreaElement(el)) {\n    var val = el.value;\n    return val.slice(0, el.selectionStart).length;\n  }\n  else {\n    var selObj = getWindowSelection(iframe); //window.getSelection();\n    if (selObj.rangeCount > 0) {\n      var selRange = selObj.getRangeAt(0);\n      var preCaretRange = selRange.cloneRange();\n      preCaretRange.selectNodeContents(el);\n      preCaretRange.setEnd(selRange.endContainer, selRange.endOffset);\n      var position = preCaretRange.toString().length;\n      return position;\n    }\n  }\n}\n\n// Based on ment.io functions...\n//\n\nfunction getDocument(iframe: HTMLIFrameElement) {\n  if (!iframe) {\n    return document;\n  } else {\n    return iframe.contentWindow.document;\n  }\n}\n\nfunction getWindowSelection(iframe: HTMLIFrameElement): Selection {\n  if (!iframe) {\n    return window.getSelection();\n  } else {\n    return iframe.contentWindow.getSelection();\n  }\n}\n\nexport function getContentEditableCaretCoords(ctx: { iframe: HTMLIFrameElement, parent?: Element }) {\n  let markerTextChar = '\\ufeff';\n  let markerId = 'sel_' + new Date().getTime() + '_' + Math.random().toString().substr(2);\n  let doc = getDocument(ctx ? ctx.iframe : null);\n  let sel = getWindowSelection(ctx ? ctx.iframe : null);\n  let prevRange = sel.getRangeAt(0);\n\n  // create new range and set postion using prevRange\n  let range = doc.createRange();\n  range.setStart(sel.anchorNode, prevRange.startOffset);\n  range.setEnd(sel.anchorNode, prevRange.startOffset);\n  range.collapse(false);\n\n  // Create the marker element containing a single invisible character\n  // using DOM methods and insert it at the position in the range\n  let markerEl = doc.createElement('span');\n  markerEl.id = markerId;\n  markerEl.appendChild(doc.createTextNode(markerTextChar));\n  range.insertNode(markerEl);\n  sel.removeAllRanges();\n  sel.addRange(prevRange);\n\n  let coordinates = {\n    left: 0,\n    top: markerEl.offsetHeight\n  };\n\n  localToRelativeCoordinates(ctx, markerEl, coordinates);\n\n  markerEl.parentNode.removeChild(markerEl);\n  return coordinates;\n}\n\nfunction localToRelativeCoordinates(\n  ctx: { iframe: HTMLIFrameElement, parent?: Element },\n  element: Element,\n  coordinates: { top: number; left: number }\n) {\n  let obj = <HTMLElement>element;\n  let iframe = ctx ? ctx.iframe : null;\n  while (obj) {\n    if (ctx.parent != null && ctx.parent == obj) {\n      break;\n    }\n    coordinates.left += obj.offsetLeft + obj.clientLeft;\n    coordinates.top += obj.offsetTop + obj.clientTop;\n    obj = <HTMLElement>obj.offsetParent;\n    if (!obj && iframe) {\n      obj = iframe;\n      iframe = null;\n    }\n  }\n  obj = <HTMLElement>element;\n  iframe = ctx ? ctx.iframe : null;\n  while (obj !== getDocument(null).body && obj != null) {\n    if (ctx.parent != null && ctx.parent == obj) {\n      break;\n    }\n    if (obj.scrollTop && obj.scrollTop > 0) {\n      coordinates.top -= obj.scrollTop;\n    }\n    if (obj.scrollLeft && obj.scrollLeft > 0) {\n      coordinates.left -= obj.scrollLeft;\n    }\n    obj = <HTMLElement>obj.parentNode;\n    if (!obj && iframe) {\n      obj = iframe;\n      iframe = null;\n    }\n  }\n}\n","/* From: https://github.com/component/textarea-caret-position */\n/* jshint browser: true */\n\n// (function () {\n\n  // We'll copy the properties below into the mirror div.\n  // Note that some browsers, such as Firefox, do not concatenate properties\n  // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n  // so we have to list every single property explicitly.\n  var properties = [\n    'direction',  // RTL support\n    'boxSizing',\n    'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n    'height',\n    'overflowX',\n    'overflowY',  // copy the scrollbar for IE\n\n    'borderTopWidth',\n    'borderRightWidth',\n    'borderBottomWidth',\n    'borderLeftWidth',\n    'borderStyle',\n\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n    'fontStyle',\n    'fontVariant',\n    'fontWeight',\n    'fontStretch',\n    'fontSize',\n    'fontSizeAdjust',\n    'lineHeight',\n    'fontFamily',\n\n    'textAlign',\n    'textTransform',\n    'textIndent',\n    'textDecoration',  // might not make a difference, but better be safe\n\n    'letterSpacing',\n    'wordSpacing',\n\n    'tabSize',\n    'MozTabSize'\n\n  ];\n\n  var isBrowser = (typeof window !== 'undefined');\n  var isFirefox = (isBrowser && window['mozInnerScreenX'] != null);\n\n  export function getCaretCoordinates(element, position, options) {\n    if (!isBrowser) {\n      throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n    }\n\n    var debug = options && options.debug || false;\n    if (debug) {\n      var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n      if (el) el.parentNode.removeChild(el);\n    }\n\n    // The mirror div will replicate the textarea's style\n    var div = document.createElement('div');\n    div.id = 'input-textarea-caret-position-mirror-div';\n    document.body.appendChild(div);\n\n    var style = div.style;\n    var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n    var isInput = element.nodeName === 'INPUT';\n\n    // Default textarea styles\n    style.whiteSpace = 'pre-wrap';\n    if (!isInput)\n      style.wordWrap = 'break-word';  // only for textarea-s\n\n    // Position off-screen\n    style.position = 'absolute';  // required to return coordinates properly\n    if (!debug)\n      style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n    // Transfer the element's properties to the div\n    properties.forEach(function (prop) {\n      if (isInput && prop === 'lineHeight') {\n        // Special case for <input>s because text is rendered centered and line height may be != height\n        if (computed.boxSizing === \"border-box\") {\n          var height = parseInt(computed.height);\n          var outerHeight =\n            parseInt(computed.paddingTop) +\n            parseInt(computed.paddingBottom) +\n            parseInt(computed.borderTopWidth) +\n            parseInt(computed.borderBottomWidth);\n          var targetHeight = outerHeight + parseInt(computed.lineHeight);\n          if (height > targetHeight) {\n            style.lineHeight = height - outerHeight + \"px\";\n          } else if (height === targetHeight) {\n            style.lineHeight = computed.lineHeight;\n          } else {\n            style.lineHeight = '0';\n          }\n        } else {\n          style.lineHeight = computed.height;\n        }\n      } else {\n        style[prop] = computed[prop];\n      }\n    });\n\n    if (isFirefox) {\n      // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n      if (element.scrollHeight > parseInt(computed.height))\n        style.overflowY = 'scroll';\n    } else {\n      style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n    }\n\n    div.textContent = element.value.substring(0, position);\n    // The second special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput)\n      div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n\n    var span = document.createElement('span');\n    // Wrapping must be replicated *exactly*, including when a long word gets\n    // onto the next line, with whitespace at the end of the line before (#7).\n    // The  *only* reliable way to do that is to copy the *entire* rest of the\n    // textarea's content into the <span> created at the caret position.\n    // For inputs, just '.' would be enough, but no need to bother.\n    span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n    div.appendChild(span);\n\n    var coordinates = {\n      top: span.offsetTop + parseInt(computed['borderTopWidth']),\n      left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\n      height: parseInt(computed['lineHeight'])\n    };\n\n    if (debug) {\n      span.style.backgroundColor = '#aaa';\n    } else {\n      document.body.removeChild(div);\n    }\n\n    return coordinates;\n  }\n\n  // if (typeof module != 'undefined' && typeof module.exports != 'undefined') {\n  //   module.exports = getCaretCoordinates;\n  // } else if(isBrowser) {\n  //   window.getCaretCoordinates = getCaretCoordinates;\n  // }\n\n  // }());","import {\n  Component, ElementRef, Output, EventEmitter, ViewChild, Input, TemplateRef, OnInit\n} from '@angular/core';\n\nimport { isInputOrTextAreaElement, getContentEditableCaretCoords } from './mention-utils';\nimport { getCaretCoordinates } from './caret-coords';\n\n/**\n * Angular Mentions.\n * https://github.com/dmacfarlane/angular-mentions\n *\n * Copyright (c) 2016 Dan MacFarlane\n */\n@Component({\n  selector: 'mention-list',\n  styleUrls: ['./mention-list.component.css'],\n  template: `\n    <ng-template #defaultItemTemplate let-item=\"item\">\n      {{item[labelKey]}}\n    </ng-template>\n    <ul #list [hidden]=\"hidden\" class=\"dropdown-menu scrollable-menu\" [class.mention-menu]=\"!styleOff\">\n      <li *ngFor=\"let item of items; let i = index\" \n        [class.active]=\"activeIndex==i\" [class.mention-active]=\"!styleOff && activeIndex==i\">\n        <a class=\"dropdown-item\" [class.mention-item]=\"!styleOff\"\n          (mousedown)=\"activeIndex=i;itemClick.emit();$event.preventDefault()\">\n          <ng-template [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{'item':item}\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    `\n})\nexport class MentionListComponent implements OnInit {\n  @Input() labelKey: string = 'label';\n  @Input() itemTemplate: TemplateRef<any>;\n  @Output() itemClick = new EventEmitter();\n  @ViewChild('list') list: ElementRef;\n  @ViewChild('defaultItemTemplate') defaultItemTemplate: TemplateRef<any>;\n  items = [];\n  activeIndex: number = 0;\n  hidden: boolean = false;\n  dropUp: boolean = false;\n  styleOff: boolean = false;\n  private coords: {top:number, left:number} = {top:0, left:0};\n  private offset: number = 0;\n  constructor(private element: ElementRef) {}\n\n  ngOnInit() {\n    if (!this.itemTemplate) {\n      this.itemTemplate = this.defaultItemTemplate;\n    }\n  }\n\n  // lots of confusion here between relative coordinates and containers\n  position(nativeParentElement: HTMLInputElement, iframe: HTMLIFrameElement = null) {\n    if (isInputOrTextAreaElement(nativeParentElement)) {\n      // parent elements need to have postition:relative for this to work correctly?\n      this.coords = getCaretCoordinates(nativeParentElement, nativeParentElement.selectionStart, null);\n      this.coords.top = nativeParentElement.offsetTop + this.coords.top - nativeParentElement.scrollTop;\n      this.coords.left = nativeParentElement.offsetLeft + this.coords.left - nativeParentElement.scrollLeft;\n      // getCretCoordinates() for text/input elements needs an additional offset to position the list correctly\n      this.offset = this.getBlockCursorDimensions(nativeParentElement).height;\n    }\n    else if (iframe) {\n      let context: { iframe: HTMLIFrameElement, parent: Element } = { iframe: iframe, parent: iframe.offsetParent };\n      this.coords = getContentEditableCaretCoords(context);\n    }\n    else {\n      let doc = document.documentElement;\n      let scrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n      let scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n      // bounding rectangles are relative to view, offsets are relative to container?\n      let caretRelativeToView = getContentEditableCaretCoords({ iframe: iframe });\n      let parentRelativeToContainer: ClientRect = nativeParentElement.getBoundingClientRect();\n      this.coords.top = caretRelativeToView.top - parentRelativeToContainer.top + nativeParentElement.offsetTop - scrollTop;\n      this.coords.left = caretRelativeToView.left - parentRelativeToContainer.left + nativeParentElement.offsetLeft - scrollLeft;\n    }\n    // set the default/inital position\n    this.positionElement();\n  }\n\n  get activeItem() {\n    return this.items[this.activeIndex];\n  }\n\n  activateNextItem() {\n    // adjust scrollable-menu offset if the next item is out of view\n    let listEl: HTMLElement = this.list.nativeElement;\n    let activeEl = listEl.getElementsByClassName('active').item(0);\n    if (activeEl) {\n      let nextLiEl: HTMLElement = <HTMLElement> activeEl.nextSibling;\n      if (nextLiEl && nextLiEl.nodeName == \"LI\") {\n        let nextLiRect: ClientRect = nextLiEl.getBoundingClientRect();\n        if (nextLiRect.bottom > listEl.getBoundingClientRect().bottom) {\n          listEl.scrollTop = nextLiEl.offsetTop + nextLiRect.height - listEl.clientHeight;\n        }\n      }\n    }\n    // select the next item\n    this.activeIndex = Math.max(Math.min(this.activeIndex + 1, this.items.length - 1), 0);\n  }\n\n  activatePreviousItem() {\n    // adjust the scrollable-menu offset if the previous item is out of view\n    let listEl: HTMLElement = this.list.nativeElement;\n    let activeEl = listEl.getElementsByClassName('active').item(0);\n    if (activeEl) {\n      let prevLiEl: HTMLElement = <HTMLElement> activeEl.previousSibling;\n      if (prevLiEl && prevLiEl.nodeName == \"LI\") {\n        let prevLiRect: ClientRect = prevLiEl.getBoundingClientRect();\n        if (prevLiRect.top < listEl.getBoundingClientRect().top) {\n          listEl.scrollTop = prevLiEl.offsetTop;\n        }\n      }\n    }\n    // select the previous item\n    this.activeIndex = Math.max(Math.min(this.activeIndex - 1, this.items.length - 1), 0);\n  }\n\n  // reset for a new mention search\n  reset() {\n    this.list.nativeElement.scrollTop = 0;\n    this.checkBounds();\n  }\n\n  // final positioning is done after the list is shown (and the height and width are known)\n  // ensure it's in the page bounds\n  private checkBounds() {\n    let left = this.coords.left, top = this.coords.top, dropUp = this.dropUp;\n    const bounds: ClientRect = this.list.nativeElement.getBoundingClientRect();\n    // if off right of page, align right\n    if (bounds.left+bounds.width>window.innerWidth) {\n      left = (window.innerWidth - bounds.width - 10);\n    }\n    // if more than half off the bottom of the page, force dropUp\n    // if ((bounds.top+bounds.height/2)>window.innerHeight) {\n    //   dropUp = true;\n    // }\n    // if top is off page, disable dropUp\n    if (bounds.top<0) {\n      dropUp = false;\n    }\n    // set the revised/final position\n    this.positionElement(left, top, dropUp);\n  }\n\n  private positionElement(left:number=this.coords.left, top:number=this.coords.top, dropUp:boolean=this.dropUp) {\n    const el: HTMLElement = this.element.nativeElement;\n    top += dropUp ? 0 : this.offset; // top of list is next line\n    el.className = dropUp ? 'dropup' : null;\n    el.style.position = \"absolute\";\n    el.style.left = left + 'px';\n    el.style.top = top + 'px';\n  }\n\n  private getBlockCursorDimensions(nativeParentElement: HTMLInputElement) {\n    const parentStyles = window.getComputedStyle(nativeParentElement);\n    return {\n      height: parseFloat(parentStyles.lineHeight),\n      width: parseFloat(parentStyles.fontSize)\n    };\n  }\n}\n","import { ComponentFactoryResolver, Directive, ElementRef, TemplateRef, ViewContainerRef } from \"@angular/core\";\nimport { EventEmitter, Input, OnChanges, Output, SimpleChanges } from \"@angular/core\";\nimport { getCaretPosition, getValue, insertValue, setCaretPosition } from './mention-utils';\n\nimport { MentionConfig } from \"./mention-config\";\nimport { MentionListComponent } from './mention-list.component';\n\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_BUFFERED = 229;\n\n/**\n * Angular Mentions.\n * https://github.com/dmacfarlane/angular-mentions\n *\n * Copyright (c) 2017 Dan MacFarlane\n */\n@Directive({\n  selector: '[mention], [mentionConfig]',\n  host: {\n    '(keydown)': 'keyDownHandler($event)',\n    '(keypress)': 'keyPressHandler($event)',\n    '(blur)': 'blurHandler($event)',\n    'autocomplete': 'off'\n  }\n})\nexport class MentionDirective implements OnChanges {\n\n  // stores the items passed to the mentions directive and used to populate the root items in mentionConfig\n  private mentionItems:any[];\n\n  @Input('mention') set mention(items:any[]) {\n    this.mentionItems = items;\n  }\n\n  // the provided configuration object\n  @Input() mentionConfig: MentionConfig = {items:[]};\n\n  private activeConfig: MentionConfig;\n\n  private DEFAULT_CONFIG: MentionConfig = {\n    items: [],\n    triggerChar: '@',\n    labelKey: 'label',\n    maxItems: -1,\n    allowSpace: false,\n    mentionSelect: (item: any) => this.activeConfig.triggerChar + item[this.activeConfig.labelKey]\n  }\n\n  // template to use for rendering list items\n  @Input() mentionListTemplate: TemplateRef<any>;\n\n  // event emitted whenever the search term changes\n  @Output() searchTerm = new EventEmitter();\n\n  private triggerChars:{[key:string]:MentionConfig} = {};\n\n  private searchString: string;\n  private startPos: number;\n  private startNode;\n  private searchList: MentionListComponent;\n  private searching: boolean;\n  private iframe: any; // optional\n  private lastKeyCode: number;\n\n  constructor(\n    private _element: ElementRef,\n    private _componentResolver: ComponentFactoryResolver,\n    private _viewContainerRef: ViewContainerRef\n  ) {}\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['mention'] || changes['mentionConfig']) {\n      this.updateConfig();\n    }\n  }\n\n  public updateConfig() {\n    let config = this.mentionConfig;\n    this.triggerChars = {};\n    // use items from directive if they have been set\n    if (this.mentionItems) {\n      config.items = this.mentionItems;\n    }\n    this.addConfig(config);\n    // nested configs\n    if (config.mentions) {\n      config.mentions.forEach(config=>this.addConfig(config));\n    }\n  }\n\n  // add configuration for a trigger char\n  private addConfig(config:MentionConfig) {\n    // defaults\n    let defaults = Object.assign({}, this.DEFAULT_CONFIG);\n    config = Object.assign(defaults, config);\n    // items\n    let items = config.items;\n    if (items && items.length>0) {\n      // convert strings to objects\n      if (typeof items[0] == 'string') {\n        items = items.map((label)=>{\n          let object = {};\n          object[config.labelKey] = label;\n          return object;\n        });\n      }\n      // remove items without an labelKey (as it's required to filter the list)\n      items = items.filter(e => e[config.labelKey]);\n      if (!config.disableSort) {\n        items.sort((a,b)=>a[config.labelKey].localeCompare(b[config.labelKey]));\n      }\n    }\n    config.items = items;\n\n    // add the config\n    this.triggerChars[config.triggerChar] = config;\n\n    // for async update while menu/search is active\n    if (this.activeConfig && this.activeConfig.triggerChar==config.triggerChar) {\n      this.activeConfig = config;\n      this.updateSearchList();\n    }\n  }\n\n  setIframe(iframe: HTMLIFrameElement) {\n    this.iframe = iframe;\n  }\n\n  stopEvent(event: any) {\n    //if (event instanceof KeyboardEvent) { // does not work for iframe\n    if (!event.wasClick) {\n      event.preventDefault();\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n    }\n  }\n\n  blurHandler(event: any) {\n    this.stopEvent(event);\n    this.stopSearch();\n  }\n\n  inputHandler(event: any, nativeElement: HTMLInputElement = this._element.nativeElement) {\n    if (this.lastKeyCode === KEY_BUFFERED && event.data) {\n      let keyCode = event.data.charCodeAt(0);\n      this.keyDownHandler({ keyCode, inputEvent: true }, nativeElement);\n    }\n  }\n\n  // @param nativeElement is the alternative text element in an iframe scenario\n  public keyPressHandler(event: any, nativeElement: HTMLInputElement = this._element.nativeElement) {\n    this.lastKeyCode = event.keyCode;\n\n    if (event.isComposing || event.keyCode === KEY_BUFFERED) {\n      return;\n    }\n\n    let pos = getCaretPosition(nativeElement, this.iframe);\n    let charPressed = this.extractCharPressed(event, pos);\n\n    let config = this.triggerChars[charPressed];\n    if (config) {\n      this.activeConfig = config;\n      this.startPos = event.inputEvent ? pos - 1 : pos;\n      this.startNode = (this.iframe ? this.iframe.contentWindow.getSelection() : window.getSelection()).anchorNode;\n      this.searching = true;\n      this.searchString = null;\n      this.showSearchList(nativeElement);\n      this.updateSearchList();\n    }\n  }\n\n  public keyDownHandler(event: any, nativeElement: HTMLInputElement = this._element.nativeElement) {\n    let val: string = getValue(nativeElement);\n    let pos = getCaretPosition(nativeElement, this.iframe);\n    let charPressed = this.extractCharPressed(event, pos);\n\n    if (event.keyCode == KEY_ENTER && event.wasClick && pos < this.startPos) {\n      // put caret back in position prior to contenteditable menu click\n      pos = this.startNode.length;\n      setCaretPosition(this.startNode, pos, this.iframe);\n    }\n    if (this.startPos >= 0 && this.searching) {\n      if (pos <= this.startPos) {\n        this.searchList.hidden = true;\n      }\n      // ignore shift when pressed alone, but not when used with another key\n      else if (event.keyCode !== KEY_SHIFT &&\n          !event.metaKey &&\n          !event.altKey &&\n          !event.ctrlKey &&\n          pos > this.startPos\n      ) {\n        if (!this.activeConfig.allowSpace && event.keyCode === KEY_SPACE) {\n          this.startPos = -1;\n        }\n        else if (event.keyCode === KEY_BACKSPACE && pos > 0) {\n          pos--;\n          if (pos == this.startPos) {\n            this.stopSearch();\n          }\n        }\n        else if (!this.searchList.hidden) {\n          if (event.keyCode === KEY_TAB || event.keyCode === KEY_ENTER) {\n            this.stopEvent(event);\n            const text = this.activeConfig.mentionSelect(this.searchList.activeItem);\n            // value is inserted without a trailing space for consistency\n            // between element types (div and iframe do not preserve the space)\n            insertValue(nativeElement, this.startPos, pos, text, this.iframe);\n            // fire input event so angular bindings are updated\n            if (\"createEvent\" in document) {\n              let evt = document.createEvent(\"HTMLEvents\");\n              if (this.iframe) {\n                // a 'change' event is required to trigger tinymce updates\n                evt.initEvent(\"change\", true, false);\n              }\n              else {\n                evt.initEvent(\"input\", true, false);\n              }\n              // this seems backwards, but fire the event from this elements nativeElement (not the\n              // one provided that may be in an iframe, as it won't be propogate)\n              this._element.nativeElement.dispatchEvent(evt);\n            }\n            this.startPos = -1;\n            this.stopSearch();\n            return false;\n          }\n          else if (event.keyCode === KEY_ESCAPE) {\n            this.stopEvent(event);\n            this.stopSearch();\n            return false;\n          }\n          else if (event.keyCode === KEY_DOWN) {\n            this.stopEvent(event);\n            this.searchList.activateNextItem();\n            return false;\n          }\n          else if (event.keyCode === KEY_UP) {\n            this.stopEvent(event);\n            this.searchList.activatePreviousItem();\n            return false;\n          }\n        }\n\n        if (event.keyCode === KEY_LEFT || event.keyCode === KEY_RIGHT) {\n          this.stopEvent(event);\n          return false;\n        }\n        else if (this.searching) {\n          let mention = val.substring(this.startPos + 1, pos);\n          if (event.keyCode !== KEY_BACKSPACE && !event.inputEvent) {\n            mention += charPressed;\n          }\n          this.searchString = mention;\n          this.searchTerm.emit(this.searchString);\n          this.updateSearchList();\n        }\n      }\n    }\n  }\n\n  stopSearch() {\n    if (this.searchList) {\n      this.searchList.hidden = true;\n    }\n    this.activeConfig = null;\n    this.searching = false;\n  }\n\n  updateSearchList() {\n    let matches: any[] = [];\n    if (this.activeConfig && this.activeConfig.items) {\n      let objects = this.activeConfig.items;\n      // disabling the search relies on the async operation to do the filtering\n      if (!this.activeConfig.disableSearch && this.searchString) {\n        let searchStringLowerCase = this.searchString.toLowerCase();\n        objects = objects.filter(e => e[this.activeConfig.labelKey].toLowerCase().startsWith(searchStringLowerCase));\n      }\n      matches = objects;\n      if (this.activeConfig.maxItems > 0) {\n        matches = matches.slice(0, this.activeConfig.maxItems);\n      }\n    }\n    // update the search list\n    if (this.searchList) {\n      this.searchList.items = matches;\n      this.searchList.hidden = matches.length == 0;\n    }\n  }\n\n  showSearchList(nativeElement: HTMLInputElement) {\n    if (this.searchList == null) {\n      let componentFactory = this._componentResolver.resolveComponentFactory(MentionListComponent);\n      let componentRef = this._viewContainerRef.createComponent(componentFactory);\n      this.searchList = componentRef.instance;\n      this.searchList.itemTemplate = this.mentionListTemplate;\n      componentRef.instance['itemClick'].subscribe(() => {\n        nativeElement.focus();\n        let fakeKeydown = { keyCode: KEY_ENTER, wasClick: true };\n        this.keyDownHandler(fakeKeydown, nativeElement);\n      });\n    }\n    this.searchList.labelKey = this.activeConfig.labelKey;\n    this.searchList.dropUp = this.activeConfig.dropUp;\n    this.searchList.styleOff = this.mentionConfig.disableStyle;\n    this.searchList.activeIndex = 0;\n    this.searchList.position(nativeElement, this.iframe);\n    window.setTimeout(() => this.searchList.reset());\n  }\n\n  private extractCharPressed(event: any, pos: any): string {\n    let charPressed = event.key;\n\n    if (!charPressed) {\n      let charCode = event.which || event.keyCode;\n      if (!event.shiftKey && (charCode >= 65 && charCode <= 90)) {\n        charPressed = String.fromCharCode(charCode + 32);\n      }\n      else if (event.shiftKey && charCode === 2) {\n        charPressed = this.DEFAULT_CONFIG.triggerChar;\n      }\n      else {\n        // TODO (dmacfarlane) fix this for non-alpha keys\n        // http://stackoverflow.com/questions/2220196/how-to-decode-character-pressed-from-jquerys-keydowns-event-handler?lq=1\n        charPressed = String.fromCharCode(event.which || event.keyCode);\n      }\n    }\n    if (event.keyCode === KEY_ENTER && event.wasClick && pos < this.startPos) {\n      // put caret back in position prior to contenteditable menu click\n      pos = this.startNode.length;\n      setCaretPosition(this.startNode, pos, this.iframe);\n    }\n    // Note: FIX for Edge (Windows - latest 44.18362.387.0) - does match @ as q+alt+ctrl\n    if (charPressed === 'q' && event.altKey && event.ctrlKey) {\n      charPressed = \"@\";\n    }\n\n    return charPressed;\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { MentionDirective } from './mention.directive';\nimport { MentionListComponent } from './mention-list.component';\n\n@NgModule({\n  declarations: [\n    MentionDirective,\n    MentionListComponent\n  ],\n  imports: [\n    CommonModule\n  ],\n  exports: [\n    MentionDirective\n  ],\n  entryComponents: [\n    MentionListComponent\n  ]\n})\nexport class MentionModule { }\n"]}